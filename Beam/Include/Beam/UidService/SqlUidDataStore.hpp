#ifndef BEAM_SQL_UID_DATA_STORE_HPP
#define BEAM_SQL_UID_DATA_STORE_HPP
#include <memory>
#include <mutex>
#include <Viper/Viper.hpp>
#include "Beam/IO/OpenState.hpp"
#include "Beam/UidService/SqlDefinitions.hpp"
#include "Beam/UidService/UidDataStore.hpp"

namespace Beam::UidService {

  /**
   * Implements the UidDataStore using SQL.
   * @param <C> The type of SQL connection.
   */
  template<typename C>
  class SqlUidDataStore : public UidDataStore {
    public:

      /** The type of SQL connection. */
      using Connection = C;

      /**
       * Constructs an SqlUidDataStore.
       * @param connection The connection to the SQL database.
       */
      SqlUidDataStore(std::unique_ptr<Connection> connection);

      ~SqlUidDataStore() override;

      std::uint64_t GetNextUid() override;

      std::uint64_t Reserve(std::uint64_t size) override;

      void WithTransaction(const std::function<void ()>& transaction) override;

      void Close() override;

    private:
      mutable std::mutex m_mutex;
      std::unique_ptr<Connection> m_connection;
      std::uint64_t m_nextUid;
      IO::OpenState m_openState;
  };

  template<typename C>
  SqlUidDataStore<C>::SqlUidDataStore(std::unique_ptr<Connection> connection)
      : m_connection(std::move(connection)) {
    try {
      m_connection->open();
      if(!m_connection->has_table("next_uid")) {
        m_connection->execute(Viper::create(GetNextUidRow(), "next_uid"));
        auto firstUid = 1;
        m_connection->execute(Viper::insert(GetNextUidRow(), "next_uid",
          &firstUid));
      }
    } catch(const std::exception&) {
      Close();
      BOOST_RETHROW;
    }
  }

  template<typename C>
  SqlUidDataStore<C>::~SqlUidDataStore() {
    Close();
  }

  template<typename C>
  std::uint64_t SqlUidDataStore<C>::GetNextUid() {
    auto nextUid = std::uint64_t();
    m_connection->execute(Viper::select(GetNextUidRow(), "next_uid", &nextUid));
    return nextUid;
  }

  template<typename C>
  std::uint64_t SqlUidDataStore<C>::Reserve(std::uint64_t size) {
    auto nextUid = GetNextUid();
    m_connection->execute(Viper::update("next_uid",
      {"uid", Viper::literal(nextUid + size)}));
    return nextUid;
  }

  template<typename C>
  void SqlUidDataStore<C>::WithTransaction(
      const std::function<void ()>& transaction) {
    auto lock = std::lock_guard(m_mutex);
    Viper::transaction(*m_connection, transaction);
  }

  template<typename C>
  void SqlUidDataStore<C>::Close() {
    if(m_openState.SetClosing()) {
      return;
    }
    m_connection->close();
    m_openState.Close();
  }
}

#endif
